01.能够理解线程通信概念
      * void wait(); 等待，让当前正在执行的线程释放CPU的使用权，进入无限等待状态。
      * void notify(); 唤醒，随机唤醒一个正在等待的线程，让其进入可运行状态。
      * void notifyAll(); 唤醒所有，唤醒所有正在等待的线程，让其进入可运行状态。

02.能够理解等待唤醒机制
        *void wait(); 等待，让当前正在执行的线程释放CPU的使用权，进入无限等待状态。
        * void notify(); 唤醒，随机唤醒一个正在等待的线程，让其进入可运行状态。
        * void notifyAll(); 唤醒所有，唤醒所有正在等待的线程，让其进入可运行状态。
03.能够描述Java中线程池运行原理
        放一些固定的线程，重复的使用。

04.能够理解函数式编程相对于面向对象的优点
     简化代码。

05.能够掌握Lambda表达式的标准格式
   （参数列表）-> {}

06.能够使用Lambda标准格式使用Runnable与Comparator接口
   只要是函数式接口都可以简化 。
   参见代码。

07.能够掌握Lambda表达式的省略格式与规则
  *  省略规则：
  *     （1）如果重写的方法没有一个形参数：()也不能省略。
  *
  *     （2）如果重写的方法有一个形参数：
  *          类型可以省略
  *          括号也可以省略
  *          变量名称可以任意指定
  *
  *     （3）如果重写的方法有2个或者2个以上的形参数：
  *          类型可以省略
  *          括号”不可以“省略
  *          变量名称可以任意指定
  *
  *     ---------------------------------------
  *     如果方法体代码只有一行 可以省略大括号。
  *     如果方法体代码只有一行 而这行是返回值 应该省略大括号还必须要省略return

08.能够使用Lambda省略格式使用Runnable与Comparator接口
     参见代码。
     Collections.sort(stus, ( o1,  o2) -> o1.getAge() - o2.getAge() );


09.能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法）
     @FunctionalInterface
     public interface CookFood {
         void cook();
     }

10.能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法）
    能省略就省略。

11.能够明确Lambda的两项使用前提
   必须是函数式接口才可以使用Lambda简化。
      必须是接口
      接口中只能有一个抽象方法